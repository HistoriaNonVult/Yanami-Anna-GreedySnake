import tkinter as tk
from PIL import Image, ImageTk
import random
import pygame
import os
import math
import time

# åˆå§‹åŒ– pygame
pygame.mixer.init()

# è·å–å½“å‰è„šæœ¬æ‰€åœ¨ç›®å½•
current_dir = os.path.dirname(os.path.abspath(__file__))

def initialize_high_score_file():
    """åˆå§‹åŒ–æœ€é«˜åˆ†æ–‡ä»¶"""
    # è·å–ç¨‹åºè¿è¡Œç›®å½•
    current_dir = os.path.dirname(os.path.abspath(__file__))
    high_score_path = os.path.join(current_dir, 'high_score.txt')
    
    # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒå¹¶åˆå§‹åŒ–ä¸º0
    if not os.path.exists(high_score_path):
        try:
            with open(high_score_path, 'w') as file:
                file.write('0')
            print(f"Created high score file at: {high_score_path}")
        except Exception as e:
            print(f"Error creating high score file: {e}")

def load_high_score():
    """åŠ è½½æœ€é«˜åˆ†ï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨åˆ™åˆ›å»º"""
    current_dir = os.path.dirname(os.path.abspath(__file__))
    high_score_path = os.path.join(current_dir, 'high_score.txt')
    
    try:
        # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œå…ˆåˆ›å»ºå®ƒ
        if not os.path.exists(high_score_path):
            initialize_high_score_file()
            
        # è¯»å–æœ€é«˜åˆ†
        with open(high_score_path, 'r') as file:
            return int(file.read())
    except Exception as e:
        print(f"Error loading high score: {e}")
        return 0

def save_high_score(score):
    """ä¿å­˜æœ€é«˜åˆ†"""
    current_dir = os.path.dirname(os.path.abspath(__file__))
    high_score_path = os.path.join(current_dir, 'high_score.txt')
    
    try:
        with open(high_score_path, 'w') as file:
            file.write(str(score))
    except Exception as e:
        print(f"Error saving high score: {e}")

# åˆ›å»ºå¼€å§‹é¡µé¢ç±»
class StartPage:
    def __init__(self):
        self.window = tk.Tk()
        self.window.title("Greedy Snake")
        self.window.resizable(False, False)
        
        # è®¾ç½®çª—å£å¤§å°å’Œä½ç½®
        window_width = 410
        window_height = 720  # ä»500æ”¹ä¸º720
        screen_width = self.window.winfo_screenwidth()
        screen_height = self.window.winfo_screenheight()
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        self.window.geometry(f"{window_width}x{window_height}+{x}+{y}")
        
        # æ·»åŠ å›¾æ ‡
        icon_path = os.path.join(current_dir, "assets", "images", "snake_icon.ico")
        self.window.iconbitmap(icon_path)
        
        # åˆ›å»ºä¸»æ¡†æ¶
        main_frame = tk.Frame(self.window, bg='black')
        main_frame.pack(fill='both', expand=True)
        
        # æ·»åŠ æ ‡é¢˜
        title_label = tk.Label(
            main_frame,
            text="Greedy Snake",
            font=("Arial", 36, "bold"),
            fg="#4CAF50",
            bg="black"
        )
        title_label.pack(pady=30)
        
        # ä½¿ç”¨æ›´å®½ä½†è¾ƒä½çš„ç”»å¸ƒ
        self.canvas = tk.Canvas(
            main_frame,
            width=400,  # ä¿æŒå®½åº¦
            height=400,  # å¢åŠ é«˜åº¦ä»¥å®¹çº³è¯´æ˜æ–‡æœ¬
            bg='black',
            highlightthickness=0
        )
        self.canvas.pack(pady=10)
        
        # ç»‘å®šé¼ æ ‡ç‚¹å‡»äº‹ä»¶åˆ°æ•´ä¸ªçª—å£
        self.window.bind("<Button-1>", self.create_firework)
        
        # å­˜å‚¨çƒŸèŠ±ç²’å­
        self.particles = []
        
        # å½©è™¹è‰²åˆ—è¡¨
        self.rainbow_colors = ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#8B00FF"]
        
        # è°ƒæ•´ä¸¤æ¡è›‡çš„åˆå§‹ä½ç½®ï¼ˆyåæ ‡æ”¹ä¸ºå±…ä¸­ï¼‰
        self.snake1_pos = [(120, 45), (138, 45), (156, 45), (174, 45)]
        self.snake1_direction = "Right"
        self.snake1_colors = ["#FF69B4", "#FF1493", "#DA70D6", "#9370DB"]  # ç²‰ç´«è‰²ç³»
        
        self.snake2_pos = [(280, 45), (262, 45), (244, 45), (226, 45)]
        self.snake2_direction = "Left"
        self.snake2_colors = ["#4B0082", "#6A5ACD", "#483D8B", "#7B68EE"]  # é›è“è‰²ç³»
        
        # æ·»åŠ æ–¹å‘æƒé‡
        self.directions_weight = {
            "Left": 40,
            "Right": 40,
            "Up": 10,
            "Down": 10
        }
        
        self.draw_decorative_snakes()
        self.animate_snakes()
        
        # åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶è¯´æ˜æ–‡æœ¬
        self.draw_instructions()
        
        # åˆ›å»ºæŒ‰é’®æ¡†æ¶æ¥å®¹çº³ä¸¤ä¸ªæŒ‰é’®
        button_frame = tk.Frame(main_frame, bg='black')
        button_frame.pack(pady=20)
        
        # æ·»åŠ å¼€å§‹æŒ‰é’®
        start_button = tk.Button(
            button_frame,
            text="Start Game",
            command=self.start_game,
            width=20,
            height=2,
            bg="#4CAF50",
            fg="white",
            font=("Arial", 14, "bold")
        )
        start_button.pack(pady=10)
        
        # æ·»åŠ é€€å‡ºæŒ‰é’®
        quit_button = tk.Button(
            button_frame,
            text="Quit",
            command=self.window.quit,
            width=20,
            height=1,
            bg="#FF5722",
            fg="white",
            font=("Arial", 14, "bold")
        )
        quit_button.pack(pady=10)
        
    def draw_instructions(self):
        # åŠ è½½æœ€é«˜åˆ†
        high_score = load_high_score()
        
        # åˆ›å»ºæ¸å˜é¢œè‰²
        def generate_rainbow_colors(steps):
            colors = []
            for i in range(steps):
                hue = i / steps
                if hue < 1/6:
                    r, g, b = 1, 6*hue, 0
                elif hue < 2/6:
                    r, g, b = 1-(6*hue-1), 1, 0
                elif hue < 3/6:
                    r, g, b = 0, 1, 6*hue-2
                elif hue < 4/6:
                    r, g, b = 0, 1-(6*hue-3), 1
                elif hue < 5/6:
                    r, g, b = 6*hue-4, 0, 1
                else:
                    r, g, b = 1, 0, 1-(6*hue-5)
                
                color = f'#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}'
                colors.append(color)
            return colors
        
        rainbow_colors = generate_rainbow_colors(20)
        
        # ç»˜åˆ¶"Best Score:"æ–‡æœ¬
        text = "BEST SCORE: "
        # å‡å°åŸºç¡€å­—ç¬¦å®½åº¦
        char_width = 12.3  # ä»12æ”¹ä¸º10
        
        # ç‰¹æ®Šå­—ç¬¦é—´è·è°ƒæ•´
        char_spacing = {
            'r': -2,  # råé¢ç¼©è¿›2ä¸ªåƒç´ 
            't': -2,  # tåé¢ç¼©è¿›2ä¸ªåƒç´ 
            ' ': 4,   # ç©ºæ ¼å®½åº¦è®¾ä¸º4ä¸ªåƒç´ 
        }
        
        start_x = 200 - (len(text + str(high_score)) * char_width) / 2
        current_x = start_x
        
        for i, char in enumerate(text):
            color = rainbow_colors[int((i / len(text)) * len(rainbow_colors))]
            self.canvas.create_text(
                current_x,
                150,
                text=char,
                fill=color,
                font=("Helvetica", 16, "bold"),
                anchor="w"
            )
            # æ ¹æ®ç‰¹æ®Šå­—ç¬¦è°ƒæ•´ä¸‹ä¸€ä¸ªå­—ç¬¦çš„ä½ç½®
            current_x += char_width + char_spacing.get(char, 0)
        
        # ç»˜åˆ¶åˆ†æ•°
        self.canvas.create_text(
            current_x,
            150,
            text=str(high_score),
            fill="#FFD700",
            font=("Helvetica", 16, "bold"),
            anchor="w"
        )
        
        # åŸæœ‰çš„è¯´æ˜æ–‡æœ¬
        instructions = """
        ğŸ® Instructions:

        ğŸ¯ Controls:
        â€¢ Arrow Keys or WASD to move snake
        â€¢ P to pause/continue
        â€¢ R to restart

        ğŸ Food Types:
        â€¢ Normal Food (Red Square)   : +1 point
        â€¢ Golden Food (Gold Circle)  : +3 points, Speed Up
        â€¢ Special Food (Purple Star) : +5 points, Slow Down
        """
        
        self.canvas.create_text(
            200,  # x åæ ‡
            280,  # y åæ ‡ï¼ˆç¨å¾®å‘ä¸‹è°ƒæ•´ï¼Œä¸ºæœ€é«˜åˆ†ç•™å‡ºç©ºé—´ï¼‰
            text=instructions,
            fill="gold",
            font=("Helvetica", 12, "italic"),
            justify="left",
            anchor="center"
        )
    
    def draw_decorative_snakes(self):
        self.canvas.delete("snake")  # åªåˆ é™¤è›‡
        
        # åˆ†åˆ«ç»˜åˆ¶ä¸¤æ¡è›‡
        # ç»˜åˆ¶ç¬¬ä¸€æ¡è›‡
        for i, pos in enumerate(self.snake1_pos):
            self.canvas.create_rectangle(
                pos[0], pos[1],
                pos[0] + 16, pos[1] + 16,
                fill=self.snake1_colors[i % len(self.snake1_colors)],
                outline="",
                tags="snake"
            )
        
        # ç»˜åˆ¶ç¬¬äºŒæ¡è›‡
        for i, pos in enumerate(self.snake2_pos):
            self.canvas.create_rectangle(
                pos[0], pos[1],
                pos[0] + 16, pos[1] + 16,
                fill=self.snake2_colors[i % len(self.snake2_colors)],
                outline="",
                tags="snake"
            )
    
    def update_snake_direction(self, head_pos, current_direction):
        head_x, head_y = head_pos
        
        # æ›´æ–°è¾¹ç•Œæ£€æŸ¥çš„èŒƒå›´ï¼ˆè°ƒæ•´yè½´èŒƒå›´ï¼‰
        if (head_x >= 350 or head_x <= 50 or 
            head_y >= 80 or head_y <= 20):  # è°ƒæ•´å‚ç›´è¾¹ç•Œ
            possible_directions = []
            weights = []
            
            if head_x < 350:
                possible_directions.append("Right")
                weights.append(self.directions_weight["Right"])
            if head_x > 50:
                possible_directions.append("Left")
                weights.append(self.directions_weight["Left"])
            if head_y < 80:  # è°ƒæ•´ä¸Šè¾¹ç•Œ
                possible_directions.append("Down")
                weights.append(self.directions_weight["Down"])
            if head_y > 20:  # è°ƒæ•´ä¸‹è¾¹ç•Œ
                possible_directions.append("Up")
                weights.append(self.directions_weight["Up"])
            
            if possible_directions:
                return random.choices(
                    possible_directions,
                    weights=weights,
                    k=1
                )[0]
        elif random.random() < 0.02:
            directions = list(self.directions_weight.keys())
            weights = list(self.directions_weight.values())
            return random.choices(
                directions,
                weights=weights,
                k=1
            )[0]
        
        return current_direction
    
    def animate_snakes(self):
        if not hasattr(self, 'window'):
            return
        
        # æ›´æ–°ä¸¤æ¡è›‡çš„æ–¹å‘å’Œä½ç½®
        self.snake1_direction = self.update_snake_direction(
            self.snake1_pos[-1],
            self.snake1_direction
        )
        self.snake1_pos = self.move_snake(
            self.snake1_pos,
            self.snake1_direction
        )
        
        self.snake2_direction = self.update_snake_direction(
            self.snake2_pos[-1],
            self.snake2_direction
        )
        self.snake2_pos = self.move_snake(
            self.snake2_pos,
            self.snake2_direction
        )
        
        self.draw_decorative_snakes()
        self.window.after(20, self.animate_snakes)
    
    def move_snake(self, positions, direction):
        head_x, head_y = positions[-1]
        
        if direction == "Right":
            new_head = (head_x + 3, head_y)
        elif direction == "Left":
            new_head = (head_x - 3, head_y)
        elif direction == "Up":
            new_head = (head_x, head_y - 3)
        else:  # Down
            new_head = (head_x, head_y + 3)
        
        positions.append(new_head)
        positions.pop(0)
        return positions
    
    def create_firework(self, event):
        # ä½¿ç”¨çª—å£åæ ‡è€Œä¸æ˜¯ç”»å¸ƒåæ ‡
        for _ in range(50):
            angle = random.uniform(0, 2 * math.pi)
            speed = random.uniform(2.0, 5.0)
            particle = {
                "x": event.x,  # ä½¿ç”¨çª—å£çš„xåæ ‡
                "y": event.y,  # ä½¿ç”¨çª—å£çš„yåæ ‡
                "speed_x": math.cos(angle) * speed,
                "speed_y": math.sin(angle) * speed,
                "color": random.choice(self.rainbow_colors),
                "size": random.randint(3, 6),
                "alpha": 1.0
            }
            self.particles.append(particle)
        
        self.animate_firework()
    
    def animate_firework(self):
        self.canvas.delete("particle")
        
        for particle in self.particles[:]:
            particle["x"] += particle["speed_x"]
            particle["y"] += particle["speed_y"]
            particle["alpha"] -= 0.02
            
            if particle["alpha"] <= 0:
                self.particles.remove(particle)
                continue
            
            # åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶ç²’å­ï¼Œä½¿ç”¨çª—å£åæ ‡
            self.canvas.create_oval(
                particle["x"] - particle["size"] / 2,
                particle["y"] - particle["size"] / 2,
                particle["x"] + particle["size"] / 2,
                particle["y"] + particle["size"] / 2,
                fill=particle["color"],
                outline="",
                tags="particle"
            )
        
        if self.particles:
            self.canvas.after(30, self.animate_firework)
    
    def start_game(self):
        pygame.mixer.music.load(os.path.join(current_dir, "assets", "music", "background.mp3"))
        pygame.mixer.music.play(-1)  # å¾ªç¯æ’­æ”¾
        
        self.window.destroy()  # å…³é—­å¼€å§‹é¡µé¢
        start_main_game()  # å¯åŠ¨ä¸»æ¸¸æˆ
def start_main_game():
    # åˆ›å»ºä¸»çª—å£
    window = tk.Tk()
    window.title("Greedy Snake")
    
    # æ·»åŠ å›¾æ ‡
    icon_path = os.path.join(current_dir, "assets", "images", "snake_icon.ico")
    window.iconbitmap(icon_path)
    
    window.resizable(False, False)
    
    # è®¾ç½®æ¸¸æˆç”»å¸ƒ
    canvas = tk.Canvas(window, bg="black", height=400, width=400)
    canvas.pack()
    
    # ä¿®æ”¹èƒŒæ™¯å›¾ç‰‡åŠ è½½è·¯å¾„
    bg_image_path = os.path.join(current_dir, "assets", "images", "background.jpg")
    image = Image.open(bg_image_path)
    image = image.resize((400, 400), Image.LANCZOS)
    bg_image = ImageTk.PhotoImage(image)
    
    # åœ¨ Canvas ä¸Šåˆ›å»ºå›¾åƒï¼ˆèƒŒæ™¯ï¼‰
    canvas.create_image(0, 0, anchor=tk.NW, image=bg_image)
    # ç¡®ä¿èƒŒæ™¯å›¾ç‰‡å¯¹è±¡ä¸ä¼šè¢«åƒåœ¾å›æ”¶
    canvas.bg_image = bg_image
    
    # å®šä¹‰è›‡çš„åˆå§‹çŠ¶æ€
    snake = [(20, 20), (20, 40), (20, 60)]
    snake_direction = "Down"
    
    # ä¿®æ”¹é£Ÿç‰©ç›¸å…³çš„å˜é‡å£°æ˜
    food = None  # åˆå§‹åŒ–ä¸ºNone
    
    # å®šä¹‰æ¸¸æˆçŠ¶æ€
    game_running = True
    
    # å°†è¿™äº›å˜é‡å£°æ˜ä¸ºå…¨å±€å˜é‡
    game_paused = False
    current_score = 0
    snake_speed = 100
    
    # æ·»åŠ ç²’å­æ•ˆæœç±»
    class Particle:
        def __init__(self, x, y, color):
            self.x = x
            self.y = y
            self.color = color
            self.size = random.randint(3, 6)
            
            # ä¿®æ”¹ä¸ºæ›´é›†ä¸­çš„å–·å°„è§’åº¦ï¼Œæ¨¡æ‹Ÿç¤¼èŠ±æ•ˆæœ
            angle = random.uniform(-math.pi, math.pi)  # 360åº¦å–·å°„
            speed = random.uniform(4.0, 7.0)          # å¢åŠ åˆå§‹é€Ÿåº¦
            
            # æ·»åŠ ä¸€äº›å‘ä¸Šçš„åˆå§‹é€Ÿåº¦ï¼Œè®©ç²’å­å…ˆä¸Šå‡
            self.speed_x = math.cos(angle) * speed
            self.speed_y = math.sin(angle) * speed - 2  # å‘ä¸Šçš„åˆå§‹é€Ÿåº¦
            
            self.alpha = 1.0
            self.id = None
            self.gravity = 0.2     # å¢åŠ é‡åŠ›æ•ˆæœ
            self.drag = 0.97       # è°ƒæ•´ç©ºæ°”é˜»åŠ›
            
            # æ·»åŠ é—ªçƒæ•ˆæœ
            self.flicker_rate = random.uniform(0.05, 0.15)
            self.base_alpha = 1.0
            self.flicker_offset = random.uniform(0, math.pi * 2)
            
            # æ·»åŠ å°¾è¿¹æ•ˆæœ
            self.trail = []
            self.trail_length = 5  # å°¾è¿¹é•¿åº¦
    
    particles = []
    
    def create_food_effect(x, y, food_type):
        color = food.properties[food_type]['color']
        # æ ¹æ®é£Ÿç‰©ç±»å‹è®¾ç½®ä¸åŒçš„ç²’å­æ•°é‡å’Œæ•ˆæœ
        particle_counts = {
            'normal': 15,   # çº¢è‰²é£Ÿç‰©
            'golden': 25,   # é‡‘è‰²é£Ÿç‰©
            'special': 40   # ç´«è‰²é£Ÿç‰©
        }
        
        particle_count = particle_counts[food_type]
        
        # åˆ›å»ºç²’å­ï¼Œä»ä¸­å¿ƒç‚¹çˆ†å‘
        for _ in range(particle_count):
            particles.append(Particle(x + 10, y + 10, color))
    
    def update_particles():
        for particle in particles[:]:
            if particle.alpha <= 0:
                if particle.id:
                    canvas.delete(particle.id)
                    for trail_id in particle.trail:
                        canvas.delete(trail_id)
                particles.remove(particle)
                continue
                
            # æ›´æ–°é€Ÿåº¦å’Œä½ç½®
            particle.speed_y += particle.gravity
            particle.speed_x *= particle.drag
            particle.speed_y *= particle.drag
            
            # ä¿å­˜å‰ä¸€ä¸ªä½ç½®ç”¨äºç»˜åˆ¶å°¾è¿¹
            old_x, old_y = particle.x, particle.y
            
            particle.x += particle.speed_x
            particle.y += particle.speed_y
            
            # æ›´æ–°åŸºç¡€alphaå€¼
            particle.base_alpha -= 0.02
            
            # ç®—é—ªçƒæ•ˆæœ
            flicker = math.sin(time.time() * 10 + particle.flicker_offset) * 0.3 + 0.7
            particle.alpha = max(0, min(1, particle.base_alpha * flicker))
            
            # åˆ é™¤æ—§çš„ç²’å­å’Œå°¾è¿¹
            if particle.id:
                canvas.delete(particle.id)
            for trail_id in particle.trail:
                canvas.delete(trail_id)
            
            # ç»˜åˆ¶å°¾è¿¹
            particle.trail = []
            if particle.base_alpha > 0.3:  # åªåœ¨ç²’å­è¾ƒäº®æ—¶ç»˜åˆ¶å°¾è¿¹
                trail_alpha = particle.alpha
                for i in range(particle.trail_length):
                    trail_x = old_x + (particle.x - old_x) * (i / particle.trail_length)
                    trail_y = old_y + (particle.y - old_y) * (i / particle.trail_length)
                    trail_size = particle.size * (0.5 + i / particle.trail_length) * particle.alpha
                    
                    trail_id = canvas.create_oval(
                        trail_x - trail_size/2,
                        trail_y - trail_size/2,
                        trail_x + trail_size/2,
                        trail_y + trail_size/2,
                        fill=particle.color,
                        stipple='gray50' if trail_alpha < 0.5 else '',
                        width=0
                    )
                    particle.trail.append(trail_id)
                    trail_alpha *= 0.6
            
            # ç»˜åˆ¶ä¸»ç²’å­
            current_size = particle.size * particle.alpha
            particle.id = canvas.create_oval(
                particle.x - current_size/2,
                particle.y - current_size/2,
                particle.x + current_size/2,
                particle.y + current_size/2,
                fill=particle.color,
                stipple='gray50' if particle.alpha < 0.5 else '',
                width=0
            )
    
    def toggle_pause():
        nonlocal game_paused
        game_paused = not game_paused
        
        # æ— è®ºæ˜¯æš‚åœè¿˜æ˜¯ç»§ç»­ï¼Œéƒ½é‡æ–°ç»˜åˆ¶æ•´ä¸ªç”»é¢
        canvas.delete("all")  # æ¸…é™¤æ‰€æœ‰å†…å®¹
        canvas.create_image(0, 0, anchor=tk.NW, image=bg_image)
        draw_snake()
        draw_food()
        draw_score()
        
        if not game_paused:
            move_snake()
            pause_button.config(bg="#4CAF50")
        else:
            pause_button.config(bg="#FF5722")
    
    def reset_game():
        nonlocal snake, snake_direction, food, game_running, current_score, game_paused, snake_speed
        # åœ¨é‡ç½®ä¹‹å‰æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°æœ€é«˜åˆ†
        if not game_running:
            high_score = load_high_score()
            if current_score > high_score:
                save_high_score(current_score)
    
        # é‡ç½®æ¸¸æˆçŠ¶æ€
        snake = [(100, 100), (80, 100), (60, 100)]
        snake_direction = "Right"
        current_score = 0
        snake_speed = 100
        game_running = True
        game_paused = False
        generate_food()
        canvas.delete("all")
        canvas.create_image(0, 0, anchor=tk.NW, image=bg_image)
        draw_snake()
        draw_food()
        draw_score()
        canvas.create_image(0, 0, anchor=tk.NW, image=bg_image)
        generate_food()
        draw_snake()
        draw_food()
        draw_score()
        move_snake()
    
    # ç„¶ååˆ›å»ºæŒ‰é’®æ¡†æ¶å’ŒæŒ‰é’®
    button_frame = tk.Frame(window)
    button_frame.pack(pady=5)
    
    pause_button = tk.Button(
        button_frame, 
        text="Pause/Continue", 
        command=toggle_pause,
        width=12,
        bg="#4CAF50",
        fg="white",
        font=("Arial", 10, "bold")
    )
    pause_button.pack(side=tk.LEFT, padx=5)
    
    restart_button = tk.Button(
        button_frame, 
        text="Restart", 
        command=reset_game,
        width=10,
        bg="#2196F3",
        fg="white",
        font=("Arial", 10, "bold")
    )
    restart_button.pack(side=tk.LEFT, padx=5)
    
    # æ·»åŠ è¿”å›æŒ‰é’®
    def back_to_start():
        # åœæ­¢æ¸¸æˆéŸ³ä¹
        pygame.mixer.music.stop()
        window.destroy()
        start_page = StartPage()
        start_page.window.mainloop()
    
    back_button = tk.Button(
        button_frame,
        text="Back",
        command=back_to_start,
        width=8,
        bg="#FF5722",
        fg="white",
        font=("Arial", 10, "bold")
    )
    back_button.pack(side=tk.LEFT, padx=5)
    
    def draw_snake():
        # ä½¿ç”¨æ¸å˜æ•ˆæœï¼Œä»å¤´åˆ°å°¾é¢œè‰²é€æ¸å˜åŒ–
        INTP = random.randint(0, 2)
        
        color_schemes = [
            ["#FF69B4", "#FF1493", "#DA70D6"],  # ç²‰ç´«è‰²ç³»æ¸å˜
            ["#00CED1", "#40E0D0", "#48D1CC"],  # é’è‰²ç³»æ¸å˜
            ["#FFD700", "#FFA500", "#FF8C00"]   # é‡‘æ©™è‰²ç³»æ¸å˜
        ]
        
        colors = color_schemes[INTP]  # éšæœºé€‰æ‹©ä¸€ç§é¢œè‰²æ–¹æ¡ˆ
        
        for i, segment in enumerate(snake):
            color = colors[i % len(colors)]  # å¾ªç¯ä½¿ç”¨é¢œè‰²
            canvas.create_rectangle(
                segment[0], segment[1], 
                segment[0] + 20, segment[1] + 20, 
                fill=color,
                outline=""  # ç§»é™¤è¾¹æ¡†ä½¿å¤–è§‚æ›´å¹³æ»‘
            )
    
    class Food:
        def __init__(self, position, food_type):
            self.position = position
            self.food_type = food_type
            # ä¸åŒé£Ÿç‰©çš„å±æ€§
            self.properties = {
                'normal': {
                    'color': 'red',
                    'score': 1,
                    'effect': None,
                    'probability': 0.65  
                },
                'golden': {
                    'color': '#FFD700',  # é‡‘è‰²
                    'score': 3,
                    'effect': 'speed_up',
                    'probability': 0.24  
                },
                'special': {
                    'color': '#9C27B0',  # ç´«è‰²
                    'score': 5,
                    'effect': 'slow_down',
                    'probability': 0.11  
                }
            }
    
    def generate_food():
        nonlocal food  # æ·»åŠ nonlocalå£°æ˜
        # éšæœºä½ç½®
        new_position = (random.randint(0, 19) * 20, random.randint(0, 19) * 20)
        while new_position in snake:
            new_position = (random.randint(0, 19) * 20, random.randint(0, 19) * 20)
        
        # æ ¹æ®æ¦‚ç‡é€‰æ‹©é£Ÿç‰©ç±»å‹
        rand = random.random()
        if rand <= 0.65:
            food_type = 'normal'
        elif rand <= 0.89:
            food_type = 'golden'
        else:
            food_type = 'special'
        
        food = Food(new_position, food_type)
    
    def draw_food():
        # åˆ¶ä¸åŒç±»å‹çš„é£Ÿç‰©
        x, y = food.position
        color = food.properties[food.food_type]['color']
        
        if food.food_type == 'normal':
            # æ™®é€šé£Ÿç‰©æ˜¯æ–¹å½¢
            canvas.create_rectangle(x, y, x + 20, y + 20, fill=color)
        elif food.food_type == 'golden':
            # é‡‘è‰²é£Ÿç‰©æ˜¯åœ†å½¢
            canvas.create_oval(x, y, x + 20, y + 20, fill=color)
        else:
            # ç‰¹æ®Šé£Ÿç‰©æ˜¯æ˜Ÿå½¢ï¼ˆç®€åŒ–ä¸ºè±å½¢ï¼‰
            canvas.create_polygon(
                x + 10, y,      # ä¸Š
                x + 20, y + 10, # 
                x + 10, y + 20, # ä¸‹
                x,      y + 10, # å·¦
                fill=color
            )
    
    def move_snake():
        nonlocal snake, food, game_running, current_score, snake_speed
        if game_paused or not game_running:
            if not game_running:
                # æ£€æŸ¥æ˜¯å¦åˆ›é€ æ–°çš„æœ€é«˜åˆ†
                high_score = load_high_score()
                if current_score > high_score:
                    save_high_score(current_score)  # ä¿å­˜æ–°çš„æœ€é«˜åˆ†
                    canvas.create_text(
                        200, 300, 
                        text=f"New High Score: {current_score}!", 
                        fill="#FFD700", 
                        font=("Arial", 20, "bold")
                    )
                return
            return
        
        head_x, head_y = snake[-1]
        if snake_direction == "Up":
            new_head = (head_x, head_y - 20)
        elif snake_direction == "Down":
            new_head = (head_x, head_y + 20)
        elif snake_direction == "Left":
            new_head = (head_x - 20, head_y)
        elif snake_direction == "Right":
            new_head = (head_x + 20, head_y)
            
        # æ£€æŸ¥æ˜¯å¦æ’åˆ°å¢™å£æˆ–è‡ªå·±
        if (new_head in snake or 
            new_head[0] < 0 or new_head[0] >= 400 or 
            new_head[1] < 0 or new_head[1] >= 400):
            game_running = False
            # åœ¨æ¸¸æˆç»“æŸæ—¶æ£€æŸ¥å¹¶æ›´æ–°æœ€é«˜åˆ†
            high_score = load_high_score()
            if current_score > high_score:
                save_high_score(current_score)  # ä¿å­˜æ–°çš„æœ€é«˜åˆ†
                canvas.create_text(
                    200, 300, 
                    text=f"New High Score: {current_score}!", 
                    fill="#FFD700", 
                    font=("Arial", 20, "bold")
                )
            canvas.create_text(200, 200, text="Yanami Anna ã‹ã‚ã„!", fill="#FF4081", font=("Arial", 24))
            #canvas.create_text(200, 250, text=f"Final Score: {current_score}", fill="white", font=("Arial", 18))
            canvas.create_text(200, 250, text="Press R to restart", fill="white", font=("Arial", 18))
            return
            
        snake.append(new_head)
        
        # æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
        if food and new_head == food.position:
            # åˆ›å»ºé£Ÿç‰©æ•ˆæœ
            create_food_effect(food.position[0], food.position[1], food.food_type)
            
            score_increase = food.properties[food.food_type]['score']
            current_score += score_increase
            
            effect = food.properties[food.food_type]['effect']
            if effect == 'speed_up':
                snake_speed = max(50, snake_speed - 10)
                show_effect_message('speed_up')
            elif effect == 'slow_down':
                snake_speed = min(150, snake_speed + 10)
                show_effect_message('slow_down')
                
            generate_food()
        else:
            snake.pop(0)
            
        # é‡ç»˜æ‰€æœ‰å†…å®¹
        canvas.delete("all")
        canvas.create_image(0, 0, anchor=tk.NW, image=bg_image)
        draw_snake()
        draw_food()
        draw_score()
        
        # æ›´æ–°ç²’å­æ•ˆæœ
        update_particles()
        
        # ç¡®ä¿ç»§ç»­ç§»åŠ¨
        window.after(snake_speed, move_snake)
    
    def change_direction(new_direction):
        nonlocal snake_direction
        if new_direction == "Up" and snake_direction != "Down":
            snake_direction = "Up"
        elif new_direction == "Down" and snake_direction != "Up":
            snake_direction = "Down"
        elif new_direction == "Left" and snake_direction != "Right":
            snake_direction = "Left"
        elif new_direction == "Right" and snake_direction != "Left":
            snake_direction = "Right"
    
    def draw_score():
        snake_length = len(snake)  # è·å–è›‡çš„é•¿åº¦
        # æ˜¾ç¤ºé•¿åº¦å’Œåˆ†æ•°
        canvas.create_text(
            50, 11, 
            text=f"Length: {snake_length}", 
            fill="#FFC107", 
            font=("Arial", 16)
        )
        canvas.create_text(
            180, 11, 
            text=f"Score: {current_score}", 
            fill="#FFC107", 
            font=("Arial", 16)
        )
        if game_paused:
            canvas.create_text(
                210, 150, 
                text="PAUSED", 
                fill="#E91E63", 
                font=("Arial", 24)
            )
    
    def show_effect_message(effect):
        if effect == 'speed_up':
            message = "Speed Up!"
            color = "#FFD700"
        elif effect == 'slow_down':
            message = "Slow Down!"
            color = "#9C27B0"
        
        canvas.create_text(
            200, 100,
            text=message,
            fill=color,
            font=("Arial", 20, "bold"),
            tags="effect_message"
        )
        # 2ç§’ååˆ é™¤æ¶ˆæ¯
        window.after(2000, lambda: canvas.delete("effect_message"))
    
    # æ·»åŠ æ–°çš„æŒ‰é”®ç»‘å®š
    window.bind("<Up>", lambda event: change_direction("Up"))
    window.bind("<w>", lambda event: change_direction("Up"))
    window.bind("<Down>", lambda event: change_direction("Down"))
    window.bind("<s>", lambda event: change_direction("Down"))
    window.bind("<Left>", lambda event: change_direction("Left"))
    window.bind("<a>", lambda event: change_direction("Left"))
    window.bind("<Right>", lambda event: change_direction("Right"))
    window.bind("<d>", lambda event: change_direction("Right"))
    window.bind("<p>", lambda event: toggle_pause())  # P æš‚åœ/ç»§ç»­
    window.bind("<r>", lambda event: reset_game())    # R é”®é‡æ–°å¼€å§‹
    
    # åœ¨æ¸¸æˆåˆå§‹åŒ–éƒ¨åˆ†æ·»åŠ 
    snake_speed = 100  # åˆå§‹é€Ÿåº¦
    generate_food()    # ç”Ÿæˆç¬¬ä¸€ä¸ªé£Ÿç‰©
    draw_snake()      # ç”»è›‡
    draw_food()       # ç”»é£Ÿç‰©
    draw_score()      # æ˜¾ç¤ºåˆ†æ•°
    
    # ç«‹å³å¼€å§‹ç§»åŠ¨è›‡
    move_snake()      # ç›´æ¥è°ƒç”¨move_snakeè€Œä¸æ˜¯ä½¿ç”¨after
    
    window.mainloop()

# ä¿®æ”¹ç¨‹åºå…¥å£ç‚¹
if __name__ == "__main__":
    initialize_high_score_file()  # ç¡®ä¿æ–‡ä»¶å­˜åœ¨
    start_page = StartPage()
    start_page.window.mainloop()
